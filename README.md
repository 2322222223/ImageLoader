#图片加载库的二次封装
##简介
###前言
> - 图片加载是Android开发中最最基础的功能，为了降低开发周期和难度，我们经常会选用一些图片加载的开源库
> - 主流的有ImageLoader，Picasso，Glide，Fresco等等，选择一款好的图片加载裤就成了我们的首要问题
> - 接下来就是要进行二次封装了，这是因为主流的框架也有无法满足项目需求的时候，当我们想要换库的话，会发现很多地方需要修改(联网库已经和图片加载业务深深耦合)，这时候就要二次封装。

###主流图片加载库的对比
***Picasso***
> - 优点
>  -包较小（100k）
>  -取消不在视野范围内图片资源的加载
>  -使用最少的内存完成复杂的图片转换
>  -自动添加二级缓存
>  -任务调度优先级处理
>  -并发线程数根据网络类型调整
>  -图片的本地缓存交给同为Square出品的okhttp处理，控制图片的过期时间
> - 缺点
>  -功能较为简单
>  -自身无实现“本地缓存”

***Glide***
> - 优点
>  -  多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video）
>  - 生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）
>  -高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）
>  -高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）
> - 缺点
>  - 方法较多较复杂，因为相当于在Picasso上的改进，包较大（500k），影响不是很大

***Fresco***
> - 优点
>  - 最大的优势在于5.0以下(最低2.3)的bitmap加载。在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem区)
>  - 大大减少OOM（在更底层的Native层对OOM进行处理，图片将不再占用App的内存）
>  - 适用于需要高性能加载大量图片的场景
> - 缺点
>  - 包较大（2~3M）
>  - 用法复杂
>  - 底层涉及c++领域，阅读源码深入学习难度大


###为什么要再次封装
> - 入口统一，所有图片加载都在这一个地方管理，一目了然，即使有什么改动我也只需要改这一个类就可以了。
> - 虽然现在的第三方库已经非常好用，但是如果我们看到第三方库就拿来用的话，很可能在第三方库无法满足业务需求或者停止维护的时候，发现替换库，工作量可见一斑。这就是不封装在切库时面临的窘境！
> - 外部表现一致，内部灵活处理原则

参考：[如何正确使用开源项目？](http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&mid=2650661623&idx=1&sn=ab28ac6587e8a5ef1241be7870851355#rd)
##封装

